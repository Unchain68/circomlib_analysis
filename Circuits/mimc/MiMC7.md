# How does it work

해당 코드는 MiMC7 알고리즘을 구현한 Circom 템플릿입니다.

첫 번째 줄에서는 nrounds와 x_in을 input signal로 받고, k와 out을 output signal로 받습니다. k는 MiMC7 알고리즘의 키패딩값으로 사용되며, x_in은 입력값입니다. out은 MiMC7 알고리즘을 적용한 결과값으로 출력됩니다.

다음으로, 상수 c가 정의되어 있습니다. 이것은 MiMC7 알고리즘에서 사용하는 상수로, 91개의 값으로 이루어져 있습니다.

그리고, t2, t4, t6, t7이라는 변수가 정의되어 있습니다. 이들은 MiMC7 알고리즘의 수학적 연산을 위해 사용됩니다.

for 루프에서는 nrounds번 반복하며, t라는 변수에 k와 x_in의 값을 더한 값을 할당합니다. 이후, t2, t4, t6, t7을 계산합니다. t2는 t를 제곱한 값이며, t4는 t2의 제곱, t6은 t4와 t2의 곱으로 계산됩니다. 마지막으로, t6과 t를 곱한 값에 k를 더한 값을 out에 할당합니다.

즉, out은 nrounds번의 루프를 거쳐 MiMC7 알고리즘을 적용한 결과값입니다.

이상입니다.
```
template MiMC7(nrounds) {
    signal input x_in;
    signal input k;
    signal output out;

    var c[91] = [
        0,
        20888961410941983456478427210666206549300505294776164667214940546594746570981,
        ...
        ...
        13602139229813231349386885113156901793661719180900395818909719758150455500533
    ];

    var t;
    signal t2[nrounds];
    signal t4[nrounds];
    signal t6[nrounds];
    signal t7[nrounds-1];

    for (var i=0; i<nrounds; i++) {
        t = (i==0) ? k+x_in : k + t7[i-1] + c[i];
        t2[i] <== t*t;
        t4[i] <== t2[i]*t2[i];
        t6[i] <== t4[i]*t2[i];
        if (i<nrounds-1) {
            t7[i] <== t6[i]*t;
        } else {
            out <== t6[i]*t + k;
        }
    }
}
```
## Split-Fiestel Algorithm 

스플릿-피스트(Split-Fiestel) 알고리즘은 대칭키 암호화에서 많이 사용되는 블록 암호화 방식 중 하나입니다. 스플릿-피스트 알고리즘은 블록 단위로 암호화하는 구조를 가지고 있으며, 블록 단위로 쪼갠 데이터를 반복적으로 바꾸는 과정을 거쳐 암호화를 수행합니다.

일반적으로 스플릿-피스트 알고리즘은 입력 데이터를 두 개로 분리하여 처리합니다. 먼저 입력 데이터를 반으로 쪼갠 다음, 반으로 쪼갠 두 부분을 각각 처리하는 구조를 가지고 있습니다. 이후 두 부분의 결과를 다시 합쳐 최종적인 암호문을 생성합니다.

스플릿-피스트 알고리즘은 주로 Feistel 구조를 사용하여 구현됩니다. Feistel 구조는 입력 데이터를 블록 단위로 나눈 다음, 각 블록을 여러 번 반복적으로 처리하여 암호화하는 방식입니다. 이때, 각 반복에서 입력 데이터의 절반을 가지고 비선형 함수를 적용하고, 나머지 절반에 대해 선형 변환을 수행합니다.

스플릿-피스트 알고리즘의 구체적인 예시를 들어보자면, 입력 데이터를 64비트 블록으로 쪼갠 다음, 32비트씩 두 개의 블록으로 분리합니다. 그리고 이 두 블록을 각각 L과 R이라는 변수에 저장한 후, 이를 반복적으로 처리합니다.

처음에는 L과 R을 각각 믹싱하여 임시 변수 T에 저장합니다. 이후 T에서 비선형 함수 F를 적용하고, 그 결과를 다시 T에 저장합니다. 이때 F 함수는 대부분 S-Box 함수를 사용합니다. 이후 T와 L을 XOR 연산을 수행하여 R을 구하고, 이를 다시 L 변수에 저장합니다. 마지막으로 L과 R을 합쳐 최종적인 암호문을 생성합니다.

스플릿-피스트 알고리즘은 복호화 과정에서도 동일한 알고리즘을 적용하여 복호화를 수행할 수 있습니다. 이때, 암호화와 복호화를 수행할 때 사용하는 키는 동일해야 합니다.

## S-Box함수란?

S-Box 함수는 암호학에서 사용되는 비선형 변환 함수입니다. S-Box 함수는 입력 비트를 다른 비트 패턴으로 매핑하는데 사용됩니다.

보통 S-Box 함수는 블록 암호화의 한 부분으로 사용되며, 입력 블록의 일부분을 대응하는 출력 블록으로 바꿉니다. 이때, S-Box 함수는 암호화 키와 함께 사용되며, 키에 따라 S-Box 함수의 출력이 달라집니다.

S-Box 함수는 비선형 함수로 구성되어 있으므로, 암호화에 있어서 중요한 역할을 합니다. S-Box 함수는 전형적으로 다양한 수학적 연산(예: XOR, AND, OR, 등)을 조합하여 만들어지며, 입력에 대한 출력을 빠르게 계산할 수 있도록 하기 위해 하드웨어 구현이 가능하도록 설계되어 있습니다.

## Round 함수란?
암호학에서 라운드 함수(round function)는 대부분의 블록 암호(block cipher)에서 사용되는 함수입니다. 라운드 함수는 입력으로 받은 평문 블록(plain text block)과 라운드 키(round key)를 사용하여 암호문 블록(cipher text block)을 생성합니다.

블록 암호에서는 블록 크기가 고정되어 있기 때문에, 평문 블록을 여러 개의 블록으로 분할하고 각 블록마다 라운드 함수를 적용하는 과정을 거칩니다. 이 과정을 여러 라운드(round)로 구성하여 전체 암호화를 수행합니다.

라운드 함수는 일반적으로 다양한 암호 기법을 적용하여 구성됩니다. 예를 들어 Feistel 구조에서는 라운드 함수가 총 두 개의 함수로 구성되어 있으며, 반복적으로 적용하여 최종 암호화를 수행합니다. MiMC 알고리즘에서도 라운드 함수가 사용되며, 비선형 함수와 선형 함수를 조합하여 구성됩니다.

## 어느 부분에서 비선형 연산이 이루어 졌는가?
```
        t2[i] <== t*t;
        t4[i] <== t2[i]*t2[i];
        t6[i] <== t4[i]*t2[i];
        if (i<nrounds-1) {
            t7[i] <== t6[i]*t;
        } else {
            out <== t6[i]*t + k;
        }
```

## c 값은 노이즈 값인거야 ?

MiMC 알고리즘에서 c 값은 노이즈 값으로 사용되며, 보안성을 높이기 위해 사용됩니다. c 값은 미리 정의된 상수값으로, MiMC 알고리즘의 라운드마다 다른 c 값을 사용하므로 암호화 결과가 예측하기 어렵습니다. c 값을 바꾸면 암호화 결과도 달라지기 때문에, 공격자가 c 값을 알지 못하면 MiMC 알고리즘의 결과를 예측하기가 어렵습니다. 따라서 c 값은 MiMC 알고리즘의 보안성을 높이는 데에 큰 역할을 합니다.

## 이 알고리즘에서 c값이 정확히 어떻게 적용하길래 알기 힘든거지?

MiMC 알고리즘에서 c 값은 라운드 함수에 사용되는 상수입니다. 이 값은 알고리즘의 보안성과 안전성에 매우 중요한 역할을 합니다.

MiMC 알고리즘에서는 c 값이 미세한 노이즈를 생성하는 것과 같은 역할을 수행합니다. c 값이 무작위로 선택되면, 알고리즘이 예측 불가능한 값을 생성하게 되어, 암호학적으로 안전한 결과를 보장할 수 있습니다.

따라서, c 값은 무작위로 생성되거나, 사전 정의된 특정 규칙에 따라 생성될 수 있습니다. 이 코드에서는 c 값을 미리 계산하여 배열에 저장하고 있으며, 라운드 함수에서 c 값이 사용되어 미세한 노이즈를 생성하고 있습니다. 이렇게 생성된 노이즈는 출력값의 예측을 어렵게 만들어, 암호학적으로 안전한 결과를 보장할 수 있습니다.


## 선형조합이란

선형조합(linear combination)은 벡터들을 일정한 가중치를 곱한 후 더해서 새로운 벡터를 만드는 연산을 말합니다. 이때 가중치는 실수일 수도 있고, 다른 벡터일 수도 있습니다. 만약 벡터들의 선형조합으로 만들어진 새로운 벡터가 원래 벡터들의 일직선 상에 존재한다면, 이를 "선형적(linear)"으로 표현할 수 있다고 합니다. 즉, 선형조합이란 벡터들을 일직선 상에 올릴 수 있는 연산을 의미합니다.

## 그럼 선형조합의 결과 백터가 일직선 상에 있지 않으면 이것을 뭐라 그래 

선형 종속(dependent)이라고 합니다. 선형 종속이란 벡터들을 선형 조합해서 만든 벡터가 다른 벡터의 선형 조합으로도 표현될 수 있는 경우를 말합니다. 즉, 선형 종속인 벡터들은 불필요한 정보를 가지고 있기 때문에 데이터 분석에서는 제거하는 것이 좋습니다.
